						GOLANG TUTORIAL FOR BEGINNERS

Source: https://www.youtube.com/watch?v=yyUHQIec83I

Repo GitLab: https://gitlab.com/nanuchi/go-full-course-youtube

Go fue creado por Google en 2007 y liberado como open-source en 2009.Asi que es un lenguaje muy joven.
Al ser tan joven permite utilizar mejor los procesadores multicore actuales,además del paralelismo,las infraestructuras actuales de Clouds,etc.
La mayoría de los anteriores lenguajes no consiguen hacer esto,y simplemente ejecutan aplicaciones secuencialmente.
Go permite ejecutar esas aplicaciones en paralelo.Todo esto lo podemos apreciar en Youtube o GoogleDocs,donde varios usuarios pueden editar el mismo documento.
Una aplicación de reserva de hoteles es otro ejemplo.

Al final siempre estamos hablando de concurrencia(hacer varias cosas al mismo tiempo).Con Go se evitan problemas de Concurrencia.

NOTA: Son concurrentes Java,Go,C++
No son concurrentes: Python,Node

GO fue diseñado para ejecutarse en múltiples cores y construido para soportar concurrencia.
La concurrencia en Go es barata y fácil(supongo que no lo es en Java y C++)

				CARACTERISTICAS PRINCIPALES DE GO

Cuando Google creó Go intentó combinar:
1- La sintaxis simple y legible de un lenguaje de alto nivel de tipado dinámico como Python
2- La eficiencia y seguridad de un lenguaje de bajo nivel ,estáticamente tipado como C++
Go es un lenguaje de Backend.Se usa en microservicios,aplicaciones web,servicios de Database.
Muchas tecnologias que corren en entornos Cloud actuales están escritas en Go,como Docker,HashiCorpVault,Kubernetes,CockroachDb,...
Go necesita menos recursos de CPU y RAM,es más eficiente.
Es un lenguaje compilado,que compila a un único binario(código máquina).Por ello es consistente entre diferentes Sistemas Operativos,ya que todos ejecutarán binario.
					INSTALAR GO Y SINTAXIX BÁSICA

Para ejecutar Go necesitaré instalar el compilador Go(actualmente viene con una Go-CLI) y usar un IDE.Usaremos VSCode.

Para instalar en Ubuntu:
> sudo apt install golang

go version <- confirmar la instalación

Debo instalar en VSCode la extensión Go(la que tiene 6M downloads.Creo un file main.go y acepto todas las instalaciones posteriores.

Para empezar hay que crear un módulo con go mod init <module path>.Ese path puede ser un repo.Mod viene de module:
go mod init booking- 
Esto creará el archivo go.mod(parece como el package.json)

Aun tendré el error expected 'package',found Print.En Go todo el código debe pertenecer a un paquete.Para declarar un paquete se usa package <name> en la primera linea.El paquete donde va el main.go se llama main:

package main

Print("Hello World")

Bien,ahora veré otro error 'expected declaration,found Print'.Básicamente Go necesita un entryPoint,hay que declararlo.Un entryPoint es una función main que Go ejecutará la primero.Debe llamarse main:

func main(){
  Print("Hello World")
} <- con 'func' declaro una función

Y ahora veré que la función Print la tengo que importar también:
package main

import "fmt"

func main() {
	fmt.Print("Hello World")
}
Fmt viene de 'formatter'

Para poder ver todo esto tendré que usar su documentación.Esta aquí:
https://pkg.go.dev/std

Para ejecutar una aplicación con Go es muy sencillo,hay que usar 'go run <file name>'.Esto compilará y ejecutará también el código.

					VARIABLES Y CONSTANTES EN GO

Todo programa tiene el concepto de variables implementado,en aras de no repetir código.Son como contenedores para un valor.
Para usar variables en Go se usa la sintaxis: var <varname> = value.El intérprete inferirá el tipo al compilar:
  var first_name = "Alexander"

Recuerda que el nombre de una variable debe ser descriptivo de lo que almacena.
IMPORTANTE:a diferencia de la mayoría de lenguajes Go compila con errores si declaro una variable y no la uso.Esto lo hace para forzar escribir código de mayor calidad(en resumen,tengo que usar ese first_name en algun punto).

NOTA:lo mismo sucede si importo un paquete y no lo uso,en otros lenguajes es un warning,en Go es un error.

En cuanto a constantes se usará la keyword 'const'.No se podrá cambiar el valor de la constante durante la ejecución del programa.
Puedo usar estas variables o constantes como un argumento adicional del método fmt.Println():
	var conferenceName = "Go Conference"
	const conferenceTickets = 50
	var remainingTickets = conferenceTickets

	fmt.Println("Welcome to our "+ conferenceName +" booking application")
	fmt.Println("We have total of", conferenceTickets, "tickets available and", remainingTickets, "are still available.")

				PRINTING FORMATTED DATA

Otra opción es usar el método fmt.Printf("Some text with variable %s",variable).Inferirá en esa posición(%s) la variable.Hace más fácil la insercción de los valores de las variables en el texto:

fmt.Printf("Welcome to our %v booking application\n",conferenceName) 
Fijate que al usar Printf hay que insertar los saltos de línea manualmente
El %v se llama placeholder y según el carácter que use dirá a Go que tipo de formato utilizar.Acepta solo ciertos valores para el carácter:

%v es el formato por default,formatea por defecto	
%T Go-syntax representation of the type<- me dirá el tipo y no el valor
etc...

NOTA:todo esto lo puedo ver en la documentación,buscando por el paquete fmt

					DATA TYPES IN GO

En Go todo tiene que tener data types.En cualquier lenguaje hay múltiples tipos de datos,Go no es diferente.Sin embargo cada lenguaje suele variar un poco en cuanto a sus tipos de datos.

En Go tengo los siguientes tipos de datos:
Strings:  cualquier cadena de caracteres,usando double quotes("Casa")
Integers : representa cualquier entero,positivo o negativo(14,-3)

Estos son los más basicos.Fijate que necesitaré dobles comillas para definir un string.Bien,¿y por qué todo esto?.Porque en Go no puedo hacer esto(inicializar la variable en otra linea:

var userName
userName = "Tom"

Go no sabrá de que tipo es userName.Esto en otros lenguajes se permite,pero Go no dejará iniciar una variable sin decirle el tipo.O bien lo infiere implicitamente al darle un valor en la misma linea(var username = "Tom") o tengo que darle el tipo al estilo de Typescript:

var username string
username="Tom"

NOTA:el punto y coma es opcional en Go,pero,como siempre queda más claro el código al usarlo.

	var userName string;
	var userTickets int;
	/* ask user for their name */
	userName = "Tom"
	userTickets =2;
	fmt.Printf("User %v has booked %v tickets\n",userName,userTickets);

Fijate que los tipos son string y int y no String y Integer.Puedo observar ya que Go me informa de muchos errores en tiempo de ejecución,en el IDE,en vez de esperar a que compile.

/* %T me dirá el data type de una variable/constante */
fmt.Printf("conferenceTickets type is %T while conferenceName's data type is %T\n", conferenceTickets, conferenceName);

IMPORTANTE: Igual que en Typescript Go sacará el tipo implicitamente si asigno un valor a la variables en la misma linea.Sin embargo,puedo darle el tipo perfectamente,aunque lo fuera a sacar él.
Esto puede ser útil cuando realmente quiero otro tipo,ya que mi tipado explícito prevalecerá sobre el suyo implícito:

var conferenceName string = "Go Conference"; <- Go ya sabe que es un string
const conferenceTickets int64 = 50;
	var remainingTickets = conferenceTickets;

NOTA: el Go,igual que en C# tengo varios tipos de Integer:
uint8:unsigned integer de 8 bytes(0 to 255)
uint16: unsigned integer of 16 bytes(0 to 65535)
uint32: unsigned integer of 32 bytes=(0 to 42944967295)
uint64: unsigned 64 bytes integer= (0 a un webo)
int8: signed 8 bit integer(-128 a +127)
int16: signed 16 bytes integer(-32768 a 32767)
int32: signed 32 bytes(- varios millones a +varios millones)
int64: lo mismo

IMPORTANTE:int8 es el byte de java,int16 es el short,int32 es el int y int64 es el long de java.

En cuanto a decimales en Go hay:
float32: floating-decimal de 32 bits
float64: floating decimal de 64 bits
complex64: número complejo con float32 con parte real e imaginaria
complex128:numbero complejo con float64 con parte real e imaginaria

Todo esto que puede parecer confuso en realidad viene muy bien ya que si quiero que un numero sea siempre positivo y pequeño puedo usar un int8 o int16 y gastar menos memoria.Fijate como lo tipa Go esa constante conferenceTickets:

const conferenceTickets untyped int = 50

Como desarrollador debería ser más preciso si me lo permite el lenguaje y lo necesito:
	var conferenceName = "Go Conference";
	const conferenceTickets uint8 = 50;
	var remainingTickets uint8 = conferenceTickets;

Adicionalmente,en Go hay una "Syntactic Sugar" para definir variables(Syntactic Sugar =  una caracteristica que me deja realizar algo de una forma más sencilla).
conferenceName := "Go Conference" <- no usar <var> y usar ':=' en vez de '='

NOTA:sólo vale para variables,no vale para constantes(esto es lógico ya que no sabe si es una variable o constante,siempre creará variables).
Tampoco se puede cambiar el tipo,hay que usar el que infiera Go implicitamente.

					 MINUTO 45 GETTING USER INPUT

Para leer la entrada por teclado de un usuario usaré el mismo paquete 'fmt'.El paquete 'fmt' tiene diferentes funciones tanto para salida(ya lo hemos visto con Printf,Println) como para entrada.
También maneja la escritura a un archivo de esos datos.

Para recoger la entrada se usa el método Scan(varName),donde varName es una variable ya existente donde se almacenará el valor:
fmt.Scan(&userName).
IMPORTANTE: además tendré que usar un 'pointer'(es el símbolo &)Un pointer es una variable que apunta a la dirección en memoria de otra variable.En Go también se les llama variables especiales.

Asi pues si imprimiera fmt.Println(userName) veré su valor pero con fmt.Println(&userName) apunto a la dirección:
0xc00007a200
Si uso fmt.Scan(&userName) ya si puedo recoger la entrada del usuario.
Los apuntadores también existen en C y C++.
Al tener la función un apuntador a su dirección en memoria puede reasignarle un valor.Con todo esto en cuenta podemos ya hacer un pequeño programa de consola:
	var firstName string;
	var lastname string;
	var email string;
	var userTickets int;

	/* ask user for their name */
	fmt.Println("Enter your first name:");
	fmt.Scan(&firstName);
	
	fmt.Println("Enter your last name:");
	fmt.Scan(&lastname);
	
	fmt.Println("Enter your email:");
	fmt.Scan(&email);

	fmt.Println("Enter the number of tickets you want:");
	fmt.Scan(&userTickets);
	
	fmt.Printf("Thank you %v %v for booking %v tickets.\nYou will receive a confirmation email shortly at %v.\n",firstName,lastname,userTickets,email);

Bien,ahora habría que actualizar los tickets.Sin embargo,veré que no puedo restar un int con un uint8:

remainingTickets = remainingTickets - userTickets;
invalid operation: mismatched types uint8 and int

Una solución sería declarar los dos como unsigned de 8 bytes,otra es convertir-parsear con los métodos necesarios:
remainingTickets = remainingTickets - uint8(userTickets); <- si tengo que castearlo también podria declararlo

						ARRAYS & SLICES IN GO

En Go tenemos dos tipos de datos para almacenar grupos de variables,los arrays y los slices.
IMPORTANTE: los arrays en Go tienen un tamaño fijo.Hay que definir uno al crear el arreglo.La sintaxis para definir un array es:

/*  var array_name = [size]type{optional initial values}*/
var bookings = [5]string{"Nana","Nicole"};

Aunque normalmente no se suelen saber los valores que tendrá un array.
var array_name =[size]array_type {}
NOTA: En Go un array sólo puede tener un mismo tipo de elementos

Y también puedo resumir un poco su inicialización a (var array_name [size]type):
var bookings [50]string; <- lo mismo pero sin el = ni el {}
Si no voy a inicializarlo con valores mejor usar esta sintaxis.

Puedo ver que el %T de un array será [size]type,y sacar su longitud con len(array).Su longitud será su longitud máxima posible:
The type of the array is: [5]string
The type of the first element is: string
The size of the array is: 5

Si por ejemplo trato de asignar un elemento fuera de las medidas del arreglo Go no me va a dejar ejecutar el script,ya me va a avisar en tiempo de compilación del error:
bookings[52]="dsfsdf";
index 52 (constant of type int) is out of bounds

Sin embargo,puedo ver que los arrays en Go tienen una longitud estática,pero yo no siempre voy a saber ese número.
Ni siquiera sabré si lo voy a llenar,ni lo que va a almacenar en total...entonces¿que pasa si necesito una lista que sea dinámica en tamaño?

Go tiene los 'slices',que lo que hacen es expandirse automáticamente cuando nuevas posiciones son insertadas.

							SLICES

Un slice básicamente es una abstracción del tipo Array ya visto(lo usa por detrás).Sin embargo son mucho más flexibles,su longitud es variable y se pueden 'trozear'.obteniendo subpartes del mismo(sub-array).
Un slice se redimensionará(expandirá) cuando sea necesario

Para usar un slice simplemente no le defino el size:
var bookings []string;
Y para añadir usaré el método append(sliceName,value).Append agrega al final del elemento(como el push de Js).Si es necesario expande el slice.Fijate que necesita saber el nombre del slice
append(bookings,firstName)

Puedo ver que la longitud cambia si uso len(array | slice):
The type of the array is: [50]string
The type of the slice is: []string
The size of the array is: 50
The size of the slice is: 1
Adicionalmente,puedo usar la misma sintaxis larga que con los arrays.
var slice = []string{}

						LOOPS IN GO

Actualmente tenemos una app que tiene una entrada de datos,los recibe,los imprime y termina.Vamos a cambiar esto con un bucle.
Un loop statement permite ejecutar código múltiples veces.

En Go los bucles han sido simplificados,sólo hay uno(el for).No existen ni el while,ni el do-while...Genial.

INFINITE LOOP:
La sintaxis para  un bucle infinito es for {}.Cualquier cosa que ponga entre las llaves se repetirá indefinidamente:

for {
  ...logic
} 
Simplemente meto toda la lógica en el for {}

FOR EACH LOOP:
Vamos a  iterar sobre el slice(que es una lista) y devolver sólo el primer nombre.Para iterar usaré la keyword 'range' en un bucle for con esta sintaxis:

for index,element := range collection {}

Range itera sobre elementos de cualquier data structure(sobre cualquier cosa iterable,no solo arrays y slices).Si está iterando sobre un array o slice devolverá el indice y el propio elemento

firstNames := []string{} <- creo un slice
		
for index,booking := range bookings { <- recuerda me devuelve el index y el elem

Para separar un string vamos a usar el método Fields() que viene del paquete 'strings.Este paquete contiene funcionalidad para trabajar con strings:
for i,elem := range bookings{
  strings.Fields(elem)
}
NOTA:el método Fields separa un string usando el white space as separator:
"Nicole Smith" will become ["Nicole","Smith".
Fijate que devuelve un slice

NOTA:al importar más de un paquete hay que cambiar la sintaxis y usar import() y cada paquete además en una linea:

import (
	"fmt"
	"strings"
)
IMPORTANTE:recuerda que GO no va a dejar compilar correctamente si dejo una variable sin usar.Y no vamos a usar el index.Para ignorar una variable usaré el llamado Bland Identifier(_).
  
 for _,booking := range bookingsSlice { <- blank identifier
	firstNames = append(firstNames,strings.Split(booking," ")[0])
  }

				1H 24M IF -ELSE STATEMENT AND BOOLEANS

Realmente la aplicación debería terminar cuando la reserva de tickets llegue a 0.Habrá que preguntar tras cada reserva si remainingTickets == 0.
La sintaxis es igual que siempre:
if (boolean Expression){
   logic
}

Asi que quedará asi:
if (remainingTickets == 0) {
  fmt.Println("Sorry, we are sold out. Try again later.")
  break;
}
Fijate en el uso de break que termina el for loop y sigue con el bloque siguiente(a diferencia de return que termina todo).En nuestro caso no tenemos ese bloque.

También podemos declarar una variable booleana con el tipo bool:
var noTicketsRemaining bool = remainingTickets == 0;
O su forma "syntactic sugar":
noTicketsRemaining := remainingTickets == 0;		

Asi pues imprimiriamos si:
if(noTicketsRemaining){ ...}

Bien,y si un usuario quiere reservar más tickets de los que quedan lo mismo:
  fmt.Println("enter number of tickets to purchase: ");
  fmt.Scan(&userTickets);

	if (uint8(userTickets) > remainingTickets) {
	fmt.Printf("Sorry, we don't have enough tickets to complete your booking. Only %v tickets are available.\n", remainingTickets)
	fmt.Println("Please try again")
	continue;
}
Sin embargo,no queremos hacer un break y que salga del loop,un continue para que salte simplemente la iteración actual es suficiente.
Lógicamente sería mejor usar if/else y menos continue/break.

Como siempre puedo usar también if/else if/else(usando cuantos else if quiera):
		if (uint8(userTickets) > remainingTickets) {
			fmt.Printf("Sorry, we don't have enough tickets to complete your booking. Only %v tickets are available.\n", remainingTickets)
			fmt.Println("Please try again")
			continue;
		} else if (uint8(userTickets) == 0) {
			fmt.Println("You have to book at least one ticket")
			continue;
		}

			FOR LOOP BASED ON CONDITION

Puedo ejecutar cualquier bucle basandome en una expresión lógica:
for remainingTickets > 0 && len(bookings) < 50 { ...}
Incluso pueden ser varios boleanos(aunque con uno de ellos valdría,pues hacen lo mismo).
Esto es justo lo que estabamos haciendo con for {} ya que realmente es esto:
for true { ...} Claro que puedo obviar el true simplemente.Recuerda que puedo usar parentesis para incrementar la legibilidad:
for (true) {}

						1H 40M USER INPUT VALIDATION

Como desarrolladores debemos asegurarnos que la aplicación no cae cuando un usuario introduzca mal un dato.La aplicación debe ser robusta.

La función len() devuelve el numero de caracteres para los strings y el numero de elementos para los arrays y slices.

isValidName := len(firstName) >= 2 && len(lastname) >=2;

El método strings.Contains(string,substring):bool devuelve true o false según el substring dado en el segundo argumento exista en el string pasado en el primer argumento.

isValidEmail := strings.Contains(email,"@") && strings.Contains(email,".");

Como cualquier otro lenguaje puedo usar &&, || o ! para negar:
isValidCity := city != "singapore" || city != "new york" || city == "paris"
if (!isValidCity)...

Los if-else son super-importantes en programación ya que controlan el flujo de la aplicación.En GO hay un statement muy importante también que es el switch.

						SWITCH/CASE STATEMENT

Imagina que la aplicación puede estar en 6 ciudades diferentes y en base a cada ciudad ejecutará un código diferente:

	city := "London"

	switch city {
		case "New York":
			fmt.Println("Welcome to New York")
		case "Paris","London":
			fmt.Println("Welcome to Europe")
		case "Singapore":
			fmt.Println("Welcome to Singapore")
		default:
			fmt.Println("Welcome to the city of your dreams")
	}

Puedo agrupar valores en cada case separados por comas.

						FUNCTIONS IN GO

Nuestro código empieza a estar muy poblado.Mediante funciones puedo encapsular código en su propio contenedor(la propia función).
Cada función debería tener un nombre para poder llamarla,y además debe ser descriptivo.
Recuerda que en GO debe haber mínimo la funcion main,que arranca el programa.

Para declarar una funcion en Go se usa la palabra reservada 'func':

func greetUsers(){
	...code	
}

Lógicamente una función debe poder recibir parámetros.En GO hay que indicar el tipo ya que estoy en un lenguaje de tipado estático:

func greetUsers(confName string){
	fmt.Println("Welcome to our conference")	
}
IMPORTANTE:fijate que en el background de una funcion lo que sucede es esto:

func xxx(arg1 string,arg2 string,arg3 int){
  var arg1 string;
  var arg2 string;
  var arg3 int;
Es decir que lo primero que hace una función que recibe argumentos es crearlos.Sin embargo es algo que sucede transparente para el programador.

func greetUsers(confName string){
	fmt.Printf("Welcome to %v booking conference\n", confName);	
}
Ya puedo usarla con ese argumento:
greetUsers(conferenceName);

IMPORTANTE: En Go una función puede devolver datos como resultado.Es decir que una función puede tomar datos en la entrada(argumentos) y devolverl otros en el return.

En Go tengo que definir el tipo de ambos parámetros,tanto los de entrada como los de salida.Esto se hace con la siguiente sintaxis func nam(args)[]string {}(es como en TS pero sin el :boolean):

func getFirstNames(bookingsSlice []string)[]string {

Dado que ahora retorna algo puedo acumularlo en una variable:
firstNames := getFirstNames(bookingsSlice);
fmt.Printf("These are all the firstnames of the bookings we have made so far: %v\n", firstNames)

En GO una función puede devolver múltiples valores.Esto es diferente a la mayoria de lenguajes.De nuevo hay que especificar el tipo de datos de cada cosa que devuelva.

Adicionalmente,hay que englobar al grupo de retorno en unos paréntesis.

func validateUserInput(firstName string, lastname string, email string, userTickets int,remainingTickets int)(bool,bool,bool,bool) {
	isValidName := len(firstName) >= 2 && len(lastname) >= 2
	isValidEmail := strings.Contains(email, "@") && strings.Contains(email, ".")
	isValidTickets := userTickets > 0
	stillRemaining := (userTickets) <= remainingTickets
		
	return isValidName,isValidEmail,isValidTickets,stillRemaining
}

/* validate user input */
isValidName, isValidEmail, isValidTickets, stillRemaining := validateUserInput(firstName, lastname, email, userTickets, int(remainingTickets))

				PACKAGE LEVEL VARIABLES

Son variables definidas arriba del archivo(tras los imports) y afuera de todas las funciones.
Una variable definida a nivel de paquete es accesable por cualquier función,tanto en ese archivo como en otro con el mismo paquete:
package main;
import (
  "fmt"
  "strings"
)

var conferenceName = "Go Conference"; <- esto es una variable a nivel de paquete,accesible por el package main(importante,no admiten la declaración "syntactic sugar"

Sin embargo,recuerda que debo definir las variables en el ámbito más 'local' posible.

package main;

import (
	"fmt"
	"strings"
)
/* package level variables - no syntactic sugar */
var conferenceName = "Go Conference"
const conferenceTickets uint8 = 50
var remainingTickets uint8 = conferenceTickets

func main() {

2h22m



