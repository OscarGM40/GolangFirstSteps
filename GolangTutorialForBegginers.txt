						GOLANG TUTORIAL FOR BEGINNERS

Source: https://www.youtube.com/watch?v=yyUHQIec83I

Repo GitLab: https://gitlab.com/nanuchi/go-full-course-youtube

Go fue creado por Google en 2007 y liberado como open-source en 2009.Asi que es un lenguaje muy joven.
Al ser tan joven permite utilizar mejor los procesadores multicore actuales,además del paralelismo,las infraestructuras actuales de Clouds,etc.
La mayoría de los anteriores lenguajes no consiguen hacer esto,y simplemente ejecutan aplicaciones secuencialmente.
Go permite ejecutar esas aplicaciones en paralelo.Todo esto lo podemos apreciar en Youtube o GoogleDocs,donde varios usuarios pueden editar el mismo documento.
Una aplicación de reserva de hoteles es otro ejemplo.

Al final siempre estamos hablando de concurrencia(hacer varias cosas al mismo tiempo).Con Go se evitan problemas de Concurrencia.

NOTA: Son concurrentes Java,Go,C++
No son concurrentes: Python,Node

GO fue diseñado para ejecutarse en múltiples cores y construido para soportar concurrencia.
La concurrencia en Go es barata y fácil(supongo que no lo es en Java y C++)

				CARACTERISTICAS PRINCIPALES DE GO

Cuando Google creó Go intentó combinar:
1- La sintaxis simple y legible de un lenguaje de alto nivel de tipado dinámico como Python
2- La eficiencia y seguridad de un lenguaje de bajo nivel ,estáticamente tipado como C++
Go es un lenguaje de Backend.Se usa en microservicios,aplicaciones web,servicios de Database.
Muchas tecnologias que corren en entornos Cloud actuales están escritas en Go,como Docker,HashiCorpVault,Kubernetes,CockroachDb,...
Go necesita menos recursos de CPU y RAM,es más eficiente.
Es un lenguaje compilado,que compila a un único binario(código máquina).Por ello es consistente entre diferentes Sistemas Operativos,ya que todos ejecutarán binario.
					INSTALAR GO Y SINTAXIX BÁSICA

Para ejecutar Go necesitaré instalar el compilador Go(actualmente viene con una Go-CLI) y usar un IDE.Usaremos VSCode.

Para instalar en Ubuntu:
> sudo apt install golang

go version <- confirmar la instalación

Debo instalar en VSCode la extensión Go(la que tiene 6M downloads.Creo un file main.go y acepto todas las instalaciones posteriores.

Para empezar hay que crear un módulo con go mod init <module path>.Ese path puede ser un repo.Mod viene de module:
go mod init booking- 
Esto creará el archivo go.mod(parece como el package.json)

Aun tendré el error expected 'package',found Print.En Go todo el código debe pertenecer a un paquete.Para declarar un paquete se usa package <name> en la primera linea.El paquete donde va el main.go se llama main:

package main

Print("Hello World")

Bien,ahora veré otro error 'expected declaration,found Print'.Básicamente Go necesita un entryPoint,hay que declararlo.Un entryPoint es una función main que Go ejecutará la primero.Debe llamarse main:

func main(){
  Print("Hello World")
} <- con 'func' declaro una función

Y ahora veré que la función Print la tengo que importar también:
package main

import "fmt"

func main() {
	fmt.Print("Hello World")
}
Fmt viene de 'formatter'

Para poder ver todo esto tendré que usar su documentación.Esta aquí:
https://pkg.go.dev/std

Para ejecutar una aplicación con Go es muy sencillo,hay que usar 'go run <file name>'.Esto compilará y ejecutará también el código.

					VARIABLES Y CONSTANTES EN GO

Todo programa tiene el concepto de variables implementado,en aras de no repetir código.Son como contenedores para un valor.
Para usar variables en Go se usa la sintaxis: var <varname> = value.El intérprete inferirá el tipo al compilar:
  var first_name = "Alexander"

Recuerda que el nombre de una variable debe ser descriptivo de lo que almacena.
IMPORTANTE:a diferencia de la mayoría de lenguajes Go compila con errores si declaro una variable y no la uso.Esto lo hace para forzar escribir código de mayor calidad(en resumen,tengo que usar ese first_name en algun punto).

NOTA:lo mismo sucede si importo un paquete y no lo uso,en otros lenguajes es un warning,en Go es un error.

En cuanto a constantes se usará la keyword 'const'.No se podrá cambiar el valor de la constante durante la ejecución del programa.
Puedo usar estas variables o constantes como un argumento adicional del método fmt.Println():
	var conferenceName = "Go Conference"
	const conferenceTickets = 50
	var remainingTickets = conferenceTickets

	fmt.Println("Welcome to our "+ conferenceName +" booking application")
	fmt.Println("We have total of", conferenceTickets, "tickets available and", remainingTickets, "are still available.")

				PRINTING FORMATTED DATA

Otra opción es usar el método fmt.Printf("Some text with variable %s",variable).Inferirá en esa posición(%s) la variable.Hace más fácil la insercción de los valores de las variables en el texto:

fmt.Printf("Welcome to our %v booking application\n",conferenceName) 
Fijate que al usar Printf hay que insertar los saltos de línea manualmente
El %v se llama placeholder y según el carácter que use dirá a Go que tipo de formato utilizar.Acepta solo ciertos valores para el carácter:

%v es el formato por default,formatea por defecto	
%T Go-syntax representation of the type<- me dirá el tipo y no el valor
etc...

NOTA:todo esto lo puedo ver en la documentación,buscando por el paquete fmt

					DATA TYPES IN GO

En Go todo tiene que tener data types.En cualquier lenguaje hay múltiples tipos de datos,Go no es diferente.Sin embargo cada lenguaje suele variar un poco en cuanto a sus tipos de datos.

En Go tengo los siguientes tipos de datos:
Strings:  cualquier cadena de caracteres,usando double quotes("Casa")
Integers : representa cualquier entero,positivo o negativo(14,-3)

Estos son los más basicos.Fijate que necesitaré dobles comillas para definir un string.Bien,¿y por qué todo esto?.Porque en Go no puedo hacer esto(inicializar la variable en otra linea:

var userName
userName = "Tom"

Go no sabrá de que tipo es userName.Esto en otros lenguajes se permite,pero Go no dejará iniciar una variable sin decirle el tipo.O bien lo infiere implicitamente al darle un valor en la misma linea(var username = "Tom") o tengo que darle el tipo al estilo de Typescript:

var username string
username="Tom"

NOTA:el punto y coma es opcional en Go,pero,como siempre queda más claro el código al usarlo.

	var userName string;
	var userTickets int;
	/* ask user for their name */
	userName = "Tom"
	userTickets =2;
	fmt.Printf("User %v has booked %v tickets\n",userName,userTickets);

Fijate que los tipos son string y int y no String y Integer.Puedo observar ya que Go me informa de muchos errores en tiempo de ejecución,en el IDE,en vez de esperar a que compile.

/* %T me dirá el data type de una variable/constante */
fmt.Printf("conferenceTickets type is %T while conferenceName's data type is %T\n", conferenceTickets, conferenceName);

IMPORTANTE: Igual que en Typescript Go sacará el tipo implicitamente si asigno un valor a la variables en la misma linea.Sin embargo,puedo darle el tipo perfectamente,aunque lo fuera a sacar él.
Esto puede ser útil cuando realmente quiero otro tipo,ya que mi tipado explícito prevalecerá sobre el suyo implícito:

var conferenceName string = "Go Conference"; <- Go ya sabe que es un string
const conferenceTickets int64 = 50;
	var remainingTickets = conferenceTickets;

NOTA: el Go,igual que en C# tengo varios tipos de Integer:
uint8:unsigned integer de 8 bytes(0 to 255)
uint16: unsigned integer of 16 bytes(0 to 65535)
uint32: unsigned integer of 32 bytes=(0 to 42944967295)
uint64: unsigned 64 bytes integer= (0 a un webo)
int8: signed 8 bit integer(-128 a +127)
int16: signed 16 bytes integer(-32768 a 32767)
int32: signed 32 bytes(- varios millones a +varios millones)
int64: lo mismo

IMPORTANTE:int8 es el byte de java,int16 es el short,int32 es el int y int64 es el long de java.

En cuanto a decimales en Go hay:
float32: floating-decimal de 32 bits
float64: floating decimal de 64 bits
complex64: número complejo con float32 con parte real e imaginaria
complex128:numbero complejo con float64 con parte real e imaginaria

Todo esto que puede parecer confuso en realidad viene muy bien ya que si quiero que un numero sea siempre positivo y pequeño puedo usar un int8 o int16 y gastar menos memoria.Fijate como lo tipa Go esa constante conferenceTickets:

const conferenceTickets untyped int = 50

Como desarrollador debería ser más preciso si me lo permite el lenguaje y lo necesito:
	var conferenceName = "Go Conference";
	const conferenceTickets uint8 = 50;
	var remainingTickets uint8 = conferenceTickets;

Adicionalmente,en Go hay una "Syntactic Sugar" para definir variables(Syntactic Sugar =  una caracteristica que me deja realizar algo de una forma más sencilla).
conferenceName := "Go Conference" <- no usar <var> y usar ':=' en vez de '='

NOTA:sólo vale para variables,no vale para constantes(esto es lógico ya que no sabe si es una variable o constante,siempre creará variables).
Tampoco se puede cambiar el tipo,hay que usar el que infiera Go implicitamente.

					 MINUTO 45 GETTING USER INPUT

Para leer la entrada por teclado de un usuario usaré el mismo paquete 'fmt'.El paquete 'fmt' tiene diferentes funciones tanto para salida(ya lo hemos visto con Printf,Println) como para entrada.
También maneja la escritura a un archivo de esos datos.

Para recoger la entrada se usa el método Scan(varName),donde varName es una variable ya existente donde se almacenará el valor:
fmt.Scan(&userName).
IMPORTANTE: además tendré que usar un 'pointer'(es el símbolo &)Un pointer es una variable que apunta a la dirección en memoria de otra variable.En Go también se les llama variables especiales.

Asi pues si imprimiera fmt.Println(userName) veré su valor pero con fmt.Println(&userName) apunto a la dirección:
0xc00007a200
Si uso fmt.Scan(&userName) ya si puedo recoger la entrada del usuario.
Los apuntadores también existen en C y C++.
Al tener la función un apuntador a su dirección en memoria puede reasignarle un valor.Con todo esto en cuenta podemos ya hacer un pequeño programa de consola:
	var firstName string;
	var lastname string;
	var email string;
	var userTickets int;

	/* ask user for their name */
	fmt.Println("Enter your first name:");
	fmt.Scan(&firstName);
	
	fmt.Println("Enter your last name:");
	fmt.Scan(&lastname);
	
	fmt.Println("Enter your email:");
	fmt.Scan(&email);

	fmt.Println("Enter the number of tickets you want:");
	fmt.Scan(&userTickets);
	
	fmt.Printf("Thank you %v %v for booking %v tickets.\nYou will receive a confirmation email shortly at %v.\n",firstName,lastname,userTickets,email);

Bien,ahora habría que actualizar los tickets.Sin embargo,veré que no puedo restar un int con un uint8:

remainingTickets = remainingTickets - userTickets;
invalid operation: mismatched types uint8 and int

Una solución sería declarar los dos como unsigned de 8 bytes,otra es convertir-parsear con los métodos necesarios:
remainingTickets = remainingTickets - uint8(userTickets); <- si tengo que castearlo también podria declararlo

						ARRAYS & SLICES IN GO

En Go tenemos dos tipos de datos para almacenar grupos de variables,los arrays y los slices.
IMPORTANTE: los arrays en Go tienen un tamaño fijo.Hay que definir uno al crear el arreglo.La sintaxis para definir un array es:

/*  var array_name = [size]type{optional initial values}*/
var bookings = [5]string{"Nana","Nicole"};

Aunque normalmente no se suelen saber los valores que tendrá un array.
var array_name =[size]array_type {}
NOTA: En Go un array sólo puede tener un mismo tipo de elementos

Y también puedo resumir un poco su inicialización a (var array_name [size]type):
var bookings [50]string; <- lo mismo pero sin el = ni el {}
Si no voy a inicializarlo con valores mejor usar esta sintaxis.

Puedo ver que el %T de un array será [size]type,y sacar su longitud con len(array).Su longitud será su longitud máxima posible:
The type of the array is: [5]string
The type of the first element is: string
The size of the array is: 5

Si por ejemplo trato de asignar un elemento fuera de las medidas del arreglo Go no me va a dejar ejecutar el script,ya me va a avisar en tiempo de compilación del error:
bookings[52]="dsfsdf";
index 52 (constant of type int) is out of bounds

Sin embargo,puedo ver que los arrays en Go tienen una longitud estática,pero yo no siempre voy a saber ese número.
Ni siquiera sabré si lo voy a llenar,ni lo que va a almacenar en total...entonces¿que pasa si necesito una lista que sea dinámica en tamaño?

Go tiene los 'slices',que lo que hacen es expandirse automáticamente cuando nuevas posiciones son insertadas.

							SLICES

Un slice básicamente es una abstracción del tipo Array ya visto(lo usa por detrás).Sin embargo son mucho más flexibles,su longitud es variable y se pueden 'trozear'.obteniendo subpartes del mismo(sub-array).
Un slice se redimensionará(expandirá) cuando sea necesario

Para usar un slice simplemente no le defino el size:
var bookings []string;
Y para añadir usaré el método append(sliceName,value).Append agrega al final del elemento(como el push de Js).Si es necesario expande el slice.Fijate que necesita saber el nombre del slice
append(bookings,firstName)

Puedo ver que la longitud cambia si uso len(array | slice):
The type of the array is: [50]string
The type of the slice is: []string
The size of the array is: 50
The size of the slice is: 1
Adicionalmente,puedo usar la misma sintaxis larga que con los arrays.
var slice = []string{}

								LOOPS IN GO
Minuto 1h11m

 
